<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="utf-8" />
    <title>Good Forces - Unity WebGL Player | Aviator</title>
    <link rel="shortcut icon" href="TemplateData/favicon.ico">
    <link rel="stylesheet" href="TemplateData/style.css">
    <link rel="manifest" href="manifest.webmanifest">
</head>
<body>
<div id="unity-container">
    <canvas id="unity-canvas" width=960 height=640 tabindex="-1"></canvas>
    <div id="unity-loading-bar">
        <div id="unity-logo"></div>
        <div id="unity-progress-bar-empty"><div id="unity-progress-bar-full"></div></div>
    </div>
    <div id="unity-warning"> </div>
</div>

<script>
    (function() {
        if (typeof window === 'undefined') return;

        // очередь сообщений, которые нужно отправить в Unity, если unityInstance ещё не готов
        window._unityMessageQueue = window._unityMessageQueue || [];

        // безопасная отправка сообщения в Unity: если unityInstance готов — отправляем,
        // иначе — кладём в очередь
        if (typeof window._sendUnityMessageSafe !== 'function') {
            window._sendUnityMessageSafe = function(gameObject, methodName, payload) {
                try {
                    payload = (payload === undefined || payload === null) ? '' : payload;

                    if (window.unityInstance && typeof window.unityInstance.SendMessage === 'function') {
                        window.unityInstance.SendMessage(gameObject, methodName, payload);
                        return true;
                    } else {
                        window._unityMessageQueue.push({
                            gameObject: gameObject,
                            methodName: methodName,
                            payload: payload
                        });
                        return false;
                    }
                } catch (e) {
                    console.error("_sendUnityMessageSafe error:", e);
                    try {
                        window._unityMessageQueue = window._unityMessageQueue || [];
                        window._unityMessageQueue.push({
                            gameObject: gameObject,
                            methodName: methodName,
                            payload: payload
                        });
                    } catch (ee) { console.warn("queue push failed", ee); }
                    return false;
                }
            };
        }

        // функция для очистки очереди — отправляет все накопленные сообщения в Unity
        if (typeof window._flushUnityQueue !== 'function') {
            window._flushUnityQueue = function() {
                if (!window._unityMessageQueue || !window._unityMessageQueue.length) return;
                if (!window.unityInstance || typeof window.unityInstance.SendMessage !== 'function') return;

                try {
                    for (var i = 0; i < window._unityMessageQueue.length; i++) {
                        var it = window._unityMessageQueue[i];
                        try {
                            window.unityInstance.SendMessage(it.gameObject, it.methodName, it.payload);
                        } catch (e) {
                            console.warn("Error sending queued message", it, e);
                        }
                    }
                } catch (e) {
                    console.warn("Error flushing unity message queue", e);
                } finally {
                    window._unityMessageQueue.length = 0;
                }
            };
        }
    })();
</script>

<script>
    (function(){
        window._unityReady = false;
        window._okSdkReady = false;

        window._tryOkSdkInit = function() {
            if (window._unityReady && window._okSdkReady) {
                console.log("Both Unity and OKSDK ready - initializing OK SDK");
                if (typeof window._sendUnityMessageSafe === 'function') {
                    window._sendUnityMessageSafe('OkServiceMono', 'OnSdkScriptLoaded', JSON.stringify({loaded:true}));
                }
            }
        };
    })();
</script>

<!-- connect.js (виджеты OK) -->
<script src="https://connect.ok.ru/connect.js"></script>


<script>
    (function(){
        // Значения по умолчанию (можно переопределить выше в другом скрипте/шаблоне)
        window.OK_APP_ID = window.OK_APP_ID || "512003543994";
        window.OK_APP_KEY = window.OK_APP_KEY || "CLLEBLMGDIHBABABA";

        // Предзагрузим библиотеку OK SDK, но не вызываем init() — это сделает jslib.
        try {
            if (!document.querySelector('script[data-oksdk-preload]')) {
                var oksdkUrl = "https://cdn.jsdelivr.net/gh/odnoklassniki/ok-js-sdk@18.4/oksdk.js";
                var s = document.createElement('script');
                s.src = oksdkUrl;
                s.async = true;
                s.setAttribute('data-oksdk-preload', '1');

                s.onload = function() {
                    console.log("✅ oksdk preloaded from", oksdkUrl);
                    window._okSdkReady = true;
                    window._tryOkSdkInit();
                };

                s.onerror = function() {
                    console.warn("Failed to preload oksdk from", oksdkUrl);
                };

                document.head.appendChild(s);
            }
        } catch (e) {
            console.warn("oksdk preloader error", e);
        }
    })();
</script>

<script>
    // ServiceWorker
    window.addEventListener("load", function () {
        if ("serviceWorker" in navigator) {
            navigator.serviceWorker.register("ServiceWorker.js").catch(e => console.warn("SW reg failed", e));
        }
    });

    // IndexedDB
    window.idb = null;
    let indexedDB = window.indexedDB || window.mozIndexedDB || window.webkitIndexedDB || window.msIndexedDB || window.shimIndexedDB;

    if (indexedDB) {
        let openReq = indexedDB.open("RA1", 2);
        openReq.onupgradeneeded = function() {
            let db = openReq.result;
            if (!db.objectStoreNames.contains("Saves")) db.createObjectStore("Saves", {keyPath: "id"});
        };
        openReq.onsuccess = function() { window.idb = openReq.result; };
        openReq.onerror = function(e) { console.warn("IDB open error", e); };
    } else {
        console.warn("IndexedDB not supported in this browser");
    }

    window.getIndexedDB = function () { return window.idb; };

    // UI helper
    var canvas = document.querySelector("#unity-canvas");
    var loadingBar = document.querySelector("#unity-loading-bar");
    var progressBarFull = document.querySelector("#unity-progress-bar-full");
    var warningBanner = document.querySelector("#unity-warning");
    function unityShowBanner(msg, type) {
        function updateBannerVisibility() { warningBanner.style.display = warningBanner.children.length ? 'block' : 'none'; }
        var div = document.createElement('div'); div.innerHTML = msg; warningBanner.appendChild(div);
        if (type == 'error') div.style = 'background: red; padding: 10px;'; else { if (type == 'warning') div.style = 'background: yellow; padding: 10px;'; setTimeout(()=>{ warningBanner.removeChild(div); updateBannerVisibility(); }, 5000); }
        updateBannerVisibility();
    }

    // Unity loader
    var buildUrl = "Build";
    var loaderUrl = buildUrl + "/OK_build.loader.js";
    var config = {
        dataUrl: buildUrl + "/OK_build.data",
        frameworkUrl: buildUrl + "/OK_build.framework.js",
        codeUrl: buildUrl + "/OK_build.wasm",
        streamingAssetsUrl: "StreamingAssets",
        companyName: "MainPlayer",
    productName: "Aviator",
    productVersion: "0.3.3",
    showBanner: unityShowBanner,
    };

    if (/iPhone|iPad|iPod|Android/i.test(navigator.userAgent)) {
        var meta = document.createElement('meta'); meta.name = 'viewport';
        meta.content = 'width=device-width, height=device-height, initial-scale=1.0, user-scalable=no, shrink-to-fit=yes';
        document.getElementsByTagName('head')[0].appendChild(meta);
    }

    loadingBar.style.display = "block";

    var script = document.createElement("script");
    script.src = loaderUrl;
    script.onload = () => {
        createUnityInstance(canvas, config, (progress) => {
            progressBarFull.style.width = 100 * progress + "%";
        }).then((instance) => {
            loadingBar.style.display = "none";
            unityInstance = instance;
            window.unityInstance = instance;

            window._unityReady = true;
            console.log("Unity ready");

            // flush queue (при установке unityInstance)
            try {
                if (typeof window._flushUnityQueue === 'function') {
                    window._flushUnityQueue();
                } else {
                    // fallback flush прямо здесь
                    if (window._unityMessageQueue && window._unityMessageQueue.length && window.unityInstance && typeof window.unityInstance.SendMessage === 'function') {
                        try {
                            for (var i = 0; i < window._unityMessageQueue.length; i++) {
                                var it = window._unityMessageQueue[i];
                                try { window.unityInstance.SendMessage(it.gameObject, it.methodName, it.payload); } catch(e){ console.warn("Error sending queued message", it, e); }
                            }
                        } catch(e) { console.warn("Error flushing unity message queue", e); }
                        window._unityMessageQueue.length = 0;
                    }
                }
            } catch(e){ console.warn("flush queue error", e); }

            window._tryOkSdkInit();

        }).catch((message) => { alert(message); });
    };
    document.body.appendChild(script);
</script>
</body>
</html>
